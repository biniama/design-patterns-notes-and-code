= Design Patterns
Biniam Asnake
1.0.0

== Object Oriented Programming Concepts
Interface:: a contract that specifies the functionalities/capabilities a class should provide
Encapsulation:: hiding the implementation detail
Abstraction:: reduce complexity by hiding unnecessary details (e.g. expose only one method and making others private). Promotes less coupling.
Inheritance:: a mechanism for reusing code by creating 'is-a' relationship between parent/super and child/sub classes. Promotes DRY
Polymorphism:: Poly means 'many', morph means 'form'. Hence, it is the ability of an object to take many forms

----
UML: Unified Modelling Language - official language to model our system to represent classes and their relationships.
----

.Types of Relationships
. Inheritance relationship (line with an unfilled rectangle)
`public class Rectangle extends Shape {}`
. Composition relationship (arrow with a diamond)
```
public class Shape {
    //  Shape class is composed of a Size class
    private Size size;
}
```
. Aggregation relationship (?)
. Dependency relationship (dashed arrow)
```
public class Shape {
    // Shape class depends on the Document class
    public void render(Document doc) {}
}
```


== Design Patterns
Design patterns are general solutions to OO problems.
It is an approach to thinking about software design that incorporate the experience of developers who have had similar problems.

.Benefits
. Not reinventing the wheel
. Building resilient code that can withstand change
. Prepare for future additions and change

=== Design Principles vs Design Patterns
Design Principles:: general guidelines on how to develop quality software.
E.g. 'Encapsulate what varies'
Design Patterns:: specific design solutions often named at solving common OO problems.
E.g. The Strategy pattern, the Iterator pattern, the Factory pattern

=== Problems with inheritance
image::images/problems_with_inheritance.png[]

. Because we are overriding a lot of methods, we are not getting the benefits of inheritance like code reuse
. We have code duplicated across classes like no flying and quacking overriding
. It is hard to get the whole knowledge about ducks by looking at the super class
. Changes can lead to unintended side effects
. All behaviour is assigned at compile time. Hence, runtime behaviour change is difficult
. Inheritance is powerful but it can lead to inflexible and fragile designs.

=== Interfaces for the rescue?
. An interface defines the methods an object must have inorder to be considered a particular type
. Interfaces allow different classes to share similarities. Not all classes need to have the same behavior, though.

image::images/ducks_with_interfaces.png[]

.Problems
. It destroys code reuse - every duck will implement its own fly() and quack() method
. Hence, maintenance becomes a nightmare
. It doesn't allow for runtime changes in behaviour

image::images/review_of_attempts.png[]

image::images/encapsulte_what_varies.png[]
----
Design Principle - Encapsulate what Varies.

If some aspect of your code is changing, that's a strong indication that you need to pull out those parts that are changing and to
separate them from the rest of your code.

By separating out the parts of your code that change, you can extend or alter them without affecting the rest of your code.

This principle is fundamental to almost every design pattern.
----

image::images/program_to_interfaces.png[]

=== Strategy Pattern
Type:: Behavioural
Definition:: The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. This lets the algorithm vary
independently from clients that use it.

.Strategy pattern class diagram
image::images/strategy_pattern_class_diagram.png[]
.Pattern Example - Ducks
image::images/strategy_pattern_ducks.png[]
.Pattern Example - Phone Camera App
image::images/strategy_pattern_phone_camera_app.png[]


.favor_composition_over_inheritance
image::images/favor_composition_over_inheritance.png[]

----
Design Principle - Favor Composition over Inheritance
Instead of inheriting behavior, composition delegates the behavior to the composed object.
Leads to a more flexible and extensible design.
Allows for changing the behavior during runtime.
----

=== Adapter Pattern
Type:: Structural
Definition:: The Adapter Pattern converts the interface of a class into another interface clients expect. It allows classes to work together that couldn't
otherwise because of incompatible interfaces.

.Definition
image::images/adapter_pattern.png[]
.Class Diagram
image::images/adapter_pattern_class_diagram.png[]
.Example
image::images/adapter_pattern_example.png[]

.Adapters use Composition
. The client is composed with the adapter class, and the Adapter is composed with the adaptee.
. The adapter sits between the client and the adaptee.
. The adapter delegates calls to the adaptee, and returns any needed value.
. The advantage of the Adapter Pattern is you can add an adapter easily without having to modify the adaptee at all, and only modify the client to add the
adapter.
. Useful when working with Vendor classes which we can't modify.

----
Design Principle - Loose Coupling
The observer pattern exemplifies the design principle of loose coupling.
Loosly coupled objects are objects that interact but donot know much about each other.
Helps us to minimize complexity of a scenario.
----
image::images/loose_coupling.png[]

. The Subject/Publisher owns the copy of the data which makes the design cleaner than many objects owning the data.
. The Dependents/Subscribers/Observers gets notified when the data changes in the Subject/Publisher.

=== Observer pattern
Type:: Behavioral
Definition:: This pattern defines a one-to-many dependency between objects so that when one object changes state, all of its dependents are notified and
updated automatically.

.Class Diagram
image::images/observer_pattern_class_diagram.png[]
.Publisher and Subscribers
image::images/observer_pattern_publisher_subscribers.png[]

----
Design Principle - The Open-Closed Principle
Classes should be open for extension but closed for modification.
Ensures flexibility and maintainability because we can add new behavior without the risk of introducing bug in the existing code.
----

=== Decorator Pattern
Type::
Definition:: This pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for
extending functionality.

.Class Diagram
image::images/decorator_pattern.png[]
.Example
image::images/decorator_pattern_example.png[]
.How it works
image::images/decorator_pattern_how_it_works.png[]

Decorator pattern uses Composition in a different way than Strategy pattern.

.Inheritance Advantages
. Powerful, but it can lead to inflexible designs
. All classes inherit the same behavior

.Composition Advantages
. We can still 'inherit' behavior by composing objects
. We can make dynamic runtime decisions
. We can add new behavior without altering existing code
. We can include behaviors not considered by the creator
. The end result often proves fewer bugs and side effects, and flexible designs.

By using composition, we get *flexibility* in how we add _capabilities_ (e.g. condiments) to our _components_ (e.g. beverages).
By using inheritance (a common beverage super type), we get the type structure we need to treat sub classes as the super class (treat coffees and decorated
coffees both as beverages. So, we can decorate beverages multiple times and call get description and cost on basic coffees or decorated coffees.


=== Memento pattern
Type:: Behavioural
Purpose:: Without violating encapsulation, capture and externalise an object's internal state so that it cn be restored to this state later.
.Pattern UML
image::images/memento_pattern.png[]
.Pattern Example
image::images/memento_pattern_example.png[]

== S.O.L.I.D Principles
=== SRP - Single Responsibility Principle
Definition:: a class should only change for one reason only
Example:: Think of a restaurant. Every person has a specific role. The waiter is responsible for taking orders only. They don't cook for you.
Imagine a restaurant where the waiter takes your order, cooks for you, goes shopping and does the taxes. This is unmanageable.

